---
phase: 01-foundation-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/server/auth/github.ts
  - src/server/routes/auth.ts
  - src/server/github/client.ts
  - src/server/github/poller.ts
  - src/server/index.ts
autonomous: true

user_setup:
  - service: github-app
    why: "OAuth authentication and GitHub API access"
    account_setup:
      - task: "Create GitHub App"
        location: "GitHub Settings -> Developer settings -> GitHub Apps -> New GitHub App"
        details: |
          - App name: "GSD Orchestrator (Dev)"
          - Homepage URL: http://localhost:3000
          - Callback URL: http://localhost:3000/api/auth/callback
          - Webhook: Disabled (for now)
          - Permissions:
            * Actions: Read & Write
            * Checks: Read-only
            * Contents: Read-only
            * Metadata: Read-only
          - Where can this app be installed: Only on this account
      - task: "Generate private key"
        location: "GitHub App settings -> Generate a private key"
        details: "Download .pem file, save to project root as github-app-private-key.pem"
    env_vars:
      - name: GITHUB_APP_ID
        source: "GitHub App settings -> App ID (top of page)"
      - name: GITHUB_APP_PRIVATE_KEY_PATH
        source: "Path to downloaded .pem file (./github-app-private-key.pem)"
      - name: GITHUB_CLIENT_ID
        source: "GitHub App settings -> Client ID"
      - name: GITHUB_CLIENT_SECRET
        source: "GitHub App settings -> Generate a new client secret"

must_haves:
  truths:
    - "User can authenticate with GitHub OAuth"
    - "System maintains valid GitHub API tokens"
    - "Server can query GitHub Actions API for workflow runs"
    - "Polling updates workflow status in database"
  artifacts:
    - path: "src/server/auth/github.ts"
      provides: "GitHub OAuth flow implementation"
      exports: ["handleCallback", "getInstallationToken"]
    - path: "src/server/routes/auth.ts"
      provides: "OAuth API endpoints"
      exports: ["authRoutes"]
    - path: "src/server/github/client.ts"
      provides: "GitHub API client"
      exports: ["GitHubClient"]
    - path: "src/server/github/poller.ts"
      provides: "Workflow polling logic"
      exports: ["startPoller", "stopPoller"]
  key_links:
    - from: "src/server/routes/auth.ts"
      to: "src/server/auth/github.ts"
      via: "OAuth callback handling"
      pattern: "handleCallback"
    - from: "src/server/github/poller.ts"
      to: "src/server/github/client.ts"
      via: "API calls in polling loop"
      pattern: "listWorkflowRuns"
    - from: "src/server/github/poller.ts"
      to: "src/server/db/index.ts"
      via: "Updating workflow_runs table"
      pattern: "updateWorkflowRun"
---

<objective>
Implement GitHub App authentication and API integration with smart polling.

Purpose: Enable secure OAuth flow for user authentication and establish connection to GitHub API for querying workflow status. Implement polling infrastructure to keep local database in sync with GitHub Actions state.

Output:
- GitHub OAuth flow (login, callback, token management)
- GitHub API client using App authentication
- Smart polling service (active runs only, exponential backoff)
- API endpoints for triggering workflows
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-dashboard/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GitHub App OAuth flow</name>
  <files>
src/server/auth/github.ts
src/server/routes/auth.ts
src/server/index.ts
  </files>
  <action>
Implement GitHub App OAuth using the web application flow:

**1. Install dependencies:**
```bash
npm install @octokit/auth-app @octokit/rest jsonwebtoken
npm install -D @types/jsonwebtoken
```

**2. Create src/server/auth/github.ts:**

Export the following functions:

- `getAuthUrl(): string`
  - Constructs GitHub OAuth URL: `https://github.com/login/oauth/authorize`
  - Query params: client_id, redirect_uri (http://localhost:3000/api/auth/callback), scope (empty for App)
  - Returns full URL

- `async handleCallback(code: string): Promise<{ accessToken: string, expiresAt: number }>`
  - Exchange code for access token via POST to `https://github.com/login/oauth/access_token`
  - Use GITHUB_CLIENT_ID and GITHUB_CLIENT_SECRET
  - Return token and expiry (8 hours from now as Unix timestamp)
  - Throw error if exchange fails

- `async getInstallationToken(appId: string, privateKeyPath: string, installationId: number): Promise<string>`
  - Use @octokit/auth-app to generate installation token
  - Read private key from file system (privateKeyPath)
  - Return installation access token (valid for 1 hour)
  - This will be used by API client for authenticated requests

Store user token in memory (Map<userId, token>) for now. Single-user MVP doesn't need database storage yet.

**3. Create src/server/routes/auth.ts:**

Export Fastify plugin `authRoutes` with these endpoints:

- `GET /api/auth/login`
  - Calls getAuthUrl()
  - Returns { url: authUrl }
  - Frontend will redirect user to this URL

- `GET /api/auth/callback`
  - Receives ?code=... query param from GitHub
  - Calls handleCallback(code)
  - Stores token in memory
  - Redirects to `http://localhost:3000/dashboard` (frontend route)

- `GET /api/auth/status`
  - Returns { authenticated: boolean, expiresAt?: number }
  - Checks if token exists and not expired

- `POST /api/auth/logout`
  - Clears stored token
  - Returns { success: true }

Use proper error handling with HTTP status codes:
- 401 for auth failures
- 400 for missing params
- 500 for server errors

**4. Update src/server/index.ts:**
- Register authRoutes plugin
- Log "Auth routes registered"
  </action>
  <verify>
**Manual OAuth flow test:**

1. Start server: `npm run dev`
2. GET http://localhost:3000/api/auth/login (should return GitHub auth URL)
3. Visit URL in browser, authorize app
4. Verify redirect to /api/auth/callback with code param
5. Verify redirect to /dashboard after successful auth
6. GET http://localhost:3000/api/auth/status (should show authenticated: true)
7. POST http://localhost:3000/api/auth/logout
8. GET http://localhost:3000/api/auth/status (should show authenticated: false)

Check logs for "Auth routes registered" and no errors during OAuth flow.
  </verify>
  <done>
- Auth endpoints respond correctly
- OAuth code exchange works (can get access token)
- Token stored and retrievable
- Status endpoint reflects auth state
- Logout clears token
- No 500 errors during normal flow
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub API client and polling service</name>
  <files>
src/server/github/client.ts
src/server/github/poller.ts
src/server/routes/repos.ts
src/server/routes/workflows.ts
src/server/index.ts
  </files>
  <action>
Build GitHub API integration with smart polling:

**1. Create src/server/github/client.ts:**

Export `GitHubClient` class with Octokit wrapper:

```typescript
import { Octokit } from '@octokit/rest';

export class GitHubClient {
  private octokit: Octokit;
  
  constructor(token: string) {
    this.octokit = new Octokit({ auth: token });
  }
  
  // List workflow runs for a repo
  async listWorkflowRuns(owner: string, repo: string, perPage = 30) {
    const { data } = await this.octokit.actions.listWorkflowRunsForRepo({
      owner,
      repo,
      per_page: perPage,
      status: 'in_progress' // Only active runs for smart polling
    });
    return data.workflow_runs;
  }
  
  // Trigger workflow dispatch
  async dispatchWorkflow(owner: string, repo: string, workflowId: string, ref = 'main') {
    await this.octokit.actions.createWorkflowDispatch({
      owner,
      repo,
      workflow_id: workflowId,
      ref,
      inputs: {}
    });
  }
  
  // Get specific workflow run details
  async getWorkflowRun(owner: string, repo: string, runId: number) {
    const { data } = await this.octokit.actions.getWorkflowRun({
      owner,
      repo,
      run_id: runId
    });
    return data;
  }
}
```

**2. Create src/server/github/poller.ts:**

Export polling service with smart backoff:

```typescript
import { GitHubClient } from './client.ts';
import { getRepos, getWorkflowRuns, addWorkflowRun, updateWorkflowRun } from '../db/index.ts';

let pollerInterval: NodeJS.Timeout | null = null;
let backoffDelay = 10000; // Start at 10s
const MAX_DELAY = 60000; // Max 60s between polls

export async function startPoller(client: GitHubClient) {
  if (pollerInterval) return; // Already running
  
  async function poll() {
    const repos = getRepos();
    
    for (const repo of repos) {
      try {
        const runs = await client.listWorkflowRuns(repo.owner, repo.name);
        
        for (const run of runs) {
          const existing = getWorkflowRuns(repo.id, 100).find(r => r.id === run.id);
          
          if (!existing) {
            addWorkflowRun({
              id: run.id,
              repoId: repo.id,
              workflowName: run.name,
              status: run.status,
              conclusion: run.conclusion,
              startedAt: run.run_started_at ? new Date(run.run_started_at).getTime() : null,
              completedAt: run.completed_at ? new Date(run.completed_at).getTime() : null,
              htmlUrl: run.html_url
            });
          } else if (existing.status !== run.status || existing.conclusion !== run.conclusion) {
            updateWorkflowRun(run.id, {
              status: run.status,
              conclusion: run.conclusion,
              completedAt: run.completed_at ? new Date(run.completed_at).getTime() : null
            });
          }
        }
        
        // Reset backoff on success
        backoffDelay = 10000;
      } catch (error) {
        console.error(`Polling error for ${repo.id}:`, error);
        // Exponential backoff on errors (rate limits)
        backoffDelay = Math.min(backoffDelay * 2, MAX_DELAY);
      }
    }
  }
  
  // Initial poll
  await poll();
  
  // Schedule recurring polls
  pollerInterval = setInterval(poll, backoffDelay);
}

export function stopPoller() {
  if (pollerInterval) {
    clearInterval(pollerInterval);
    pollerInterval = null;
  }
}
```

**3. Create src/server/routes/repos.ts:**

Export Fastify plugin `repoRoutes`:

- `GET /api/repos` - List all tracked repos from database
- `POST /api/repos` - Add repo (body: { owner, name }), validate not duplicate
- `DELETE /api/repos/:id` - Remove repo by id

**4. Create src/server/routes/workflows.ts:**

Export Fastify plugin `workflowRoutes`:

- `GET /api/repos/:repoId/workflows` - List workflow runs for repo from database
- `POST /api/repos/:repoId/workflows/:workflowId/dispatch` - Trigger workflow via GitHub API

**5. Update src/server/index.ts:**
- Register repoRoutes and workflowRoutes
- Start poller after server ready: `await startPoller(new GitHubClient(token))`
- Stop poller on shutdown
- Log "Polling service started"
  </action>
  <verify>
**API tests (use curl or Postman):**

1. Add a repo: `POST /api/repos` with `{"owner":"octocat","name":"Hello-World"}`
2. List repos: `GET /api/repos` (should show added repo)
3. Check database: `sqlite3 data/orchestrator.db "SELECT * FROM repos;"`
4. Wait 15 seconds for first poll
5. Check workflow_runs: `GET /api/repos/octocat%2FHello-World/workflows`
6. Verify logs show "Polling service started" and poll activity

**Dispatch test (if repo has workflow_dispatch):**
```bash
curl -X POST http://localhost:3000/api/repos/octocat%2FHello-World/workflows/test.yml/dispatch
```
Check GitHub Actions for triggered run.
  </verify>
  <done>
- GitHub API client can list workflow runs
- Polling service fetches runs every 10s (or with backoff)
- Database updates with new/changed workflow runs
- Repo management endpoints work (add/list/remove)
- Workflow dispatch triggers GitHub Actions
- No rate limit errors (backoff working)
  </done>
</task>

</tasks>

<verification>
**End-to-end GitHub integration check:**

1. Ensure .env has all GITHUB_* variables set
2. Start server: `npm run dev`
3. Complete OAuth flow via browser
4. Add a test repo via API
5. Wait for poller to fetch workflow runs
6. Verify database contains workflow_runs
7. Dispatch a workflow via API
8. Verify run appears in GitHub Actions UI

**Rate limit check:**
```bash
# Check GitHub API rate limit status
curl -H "Authorization: Bearer $TOKEN" https://api.github.com/rate_limit
```

Should show Actions API rate limit usage.
</verification>

<success_criteria>
1. User can complete GitHub OAuth flow and get authenticated
2. Server maintains valid GitHub API token and can make authenticated requests
3. Polling service fetches workflow runs every 10-60 seconds
4. Database updates with workflow status changes (in_progress â†’ completed)
5. User can add/remove repos from tracking list
6. User can trigger workflow dispatch and see it start on GitHub
7. Exponential backoff prevents rate limiting on errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-dashboard/01-02-SUMMARY.md`
</output>
