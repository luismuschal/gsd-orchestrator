---
phase: 01-foundation-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/server/auth/github.ts
  - src/server/routes/auth.ts
  - src/server/github/client.ts
  - src/server/github/poller.ts
  - src/server/routes/repos.ts
  - src/server/routes/workflows.ts
  - src/server/index.ts
autonomous: true

user_setup:
  - service: github-app
    why: "OAuth authentication and GitHub API access"
    account_setup:
      - task: "Create GitHub App"
        location: "GitHub Settings -> Developer settings -> GitHub Apps -> New GitHub App"
        details: |
          - App name: "GSD Orchestrator (Dev)"
          - Homepage URL: http://localhost:3000
          - Callback URL: http://localhost:3000/api/auth/callback
          - Webhook: Disabled (for now)
          - Permissions:
            * Actions: Read & Write
            * Checks: Read-only
            * Contents: Read-only
            * Metadata: Read-only
          - Where can this app be installed: Only on this account
      - task: "Generate private key"
        location: "GitHub App settings -> Generate a private key"
        details: "Download .pem file, save to project root as github-app-private-key.pem"
    env_vars:
      - name: GITHUB_APP_ID
        source: "GitHub App settings -> App ID (top of page)"
      - name: GITHUB_APP_PRIVATE_KEY_PATH
        source: "Path to downloaded .pem file (./github-app-private-key.pem)"
      - name: GITHUB_CLIENT_ID
        source: "GitHub App settings -> Client ID"
      - name: GITHUB_CLIENT_SECRET
        source: "GitHub App settings -> Generate a new client secret"

must_haves:
  truths:
    - "User can authenticate with GitHub OAuth"
    - "System maintains valid GitHub API tokens"
    - "Server can query GitHub Actions API for workflow runs"
    - "Polling updates workflow status in database"
  artifacts:
    - path: "src/server/auth/github.ts"
      provides: "GitHub OAuth flow implementation"
      exports: ["handleCallback", "getInstallationToken"]
    - path: "src/server/routes/auth.ts"
      provides: "OAuth API endpoints"
      exports: ["authRoutes"]
    - path: "src/server/github/client.ts"
      provides: "GitHub API client"
      exports: ["GitHubClient"]
    - path: "src/server/github/poller.ts"
      provides: "Workflow polling logic"
      exports: ["startPoller", "stopPoller"]
  key_links:
    - from: "src/server/routes/auth.ts"
      to: "src/server/auth/github.ts"
      via: "OAuth callback handling"
      pattern: "handleCallback"
    - from: "src/server/github/poller.ts"
      to: "src/server/github/client.ts"
      via: "API calls in polling loop"
      pattern: "listWorkflowRuns"
    - from: "src/server/github/poller.ts"
      to: "src/server/db/index.ts"
      via: "Updating workflow_runs table"
      pattern: "updateWorkflowRun"
---

<objective>
Implement GitHub App authentication and API integration with smart polling.

Purpose: Enable secure OAuth flow for user authentication and establish connection to GitHub API for querying workflow status. Implement polling infrastructure to keep local database in sync with GitHub Actions state.

Output:
- GitHub OAuth flow (login, callback, token management)
- GitHub API client using App authentication
- Smart polling service (active runs only, exponential backoff)
- API endpoints for triggering workflows
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-dashboard/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GitHub App OAuth flow</name>
  <files>
src/server/auth/github.ts
src/server/routes/auth.ts
src/server/index.ts
  </files>
  <action>
Implement GitHub App OAuth using the web application flow:

**1. Install dependencies:**
```bash
npm install @octokit/auth-app @octokit/rest jsonwebtoken
npm install -D @types/jsonwebtoken
```

**2. Create src/server/auth/github.ts:**

Export the following functions:

- `getAuthUrl(): string`
  - Constructs GitHub OAuth URL: `https://github.com/login/oauth/authorize`
  - Query params: client_id, redirect_uri (http://localhost:3000/api/auth/callback), scope (empty for App)
  - Returns full URL

- `async handleCallback(code: string): Promise<{ accessToken: string, expiresAt: number }>`
  - Exchange code for access token via POST to `https://github.com/login/oauth/access_token`
  - Use GITHUB_CLIENT_ID and GITHUB_CLIENT_SECRET
  - Return token and expiry (8 hours from now as Unix timestamp)
  - Throw error if exchange fails

- `async getInstallationToken(appId: string, privateKeyPath: string, installationId: number): Promise<string>`
  - Use @octokit/auth-app to generate installation token
  - Read private key from file system (privateKeyPath)
  - Return installation access token (valid for 1 hour)
  - This will be used by API client for authenticated requests

Store user token in memory (Map<userId, token>) for now. Single-user MVP doesn't need database storage yet.

**3. Create src/server/routes/auth.ts:**

Export Fastify plugin `authRoutes` with these endpoints:

- `GET /api/auth/login`
  - Calls getAuthUrl()
  - Returns { url: authUrl }
  - Frontend will redirect user to this URL

- `GET /api/auth/callback`
  - Receives ?code=... query param from GitHub
  - Calls handleCallback(code)
  - Stores token in memory
  - Redirects to `http://localhost:3000/dashboard` (frontend route)

- `GET /api/auth/status`
  - Returns { authenticated: boolean, expiresAt?: number }
  - Checks if token exists and not expired

- `POST /api/auth/logout`
  - Clears stored token
  - Returns { success: true }

Use proper error handling with HTTP status codes:
- 401 for auth failures
- 400 for missing params
- 500 for server errors

**4. Update src/server/index.ts:**
- Register authRoutes plugin
- Log "Auth routes registered"
  </action>
  <verify>
**Manual OAuth flow test:**

1. Start server: `npm run dev`
2. GET http://localhost:3000/api/auth/login (should return GitHub auth URL)
3. Visit URL in browser, authorize app
4. Verify redirect to /api/auth/callback with code param
5. Verify redirect to /dashboard after successful auth
6. GET http://localhost:3000/api/auth/status (should show authenticated: true)
7. POST http://localhost:3000/api/auth/logout
8. GET http://localhost:3000/api/auth/status (should show authenticated: false)

Check logs for "Auth routes registered" and no errors during OAuth flow.
  </verify>
  <done>
- Auth endpoints respond correctly
- OAuth code exchange works (can get access token)
- Token stored and retrievable
- Status endpoint reflects auth state
- Logout clears token
- No 500 errors during normal flow
  </done>
</task>

<task type="auto">
  <name>Task 2a: Create GitHub API client and polling service</name>
  <files>
src/server/github/client.ts
src/server/github/poller.ts
src/server/index.ts
  </files>
  <action>
Build GitHub API client with smart polling infrastructure:

**1. Create src/server/github/client.ts:**

Export `GitHubClient` class with Octokit wrapper:

```typescript
import { Octokit } from '@octokit/rest';

export class GitHubClient {
  private octokit: Octokit;
  
  constructor(token: string) {
    this.octokit = new Octokit({ auth: token });
  }
  
  // List workflow runs for a repo
  async listWorkflowRuns(owner: string, repo: string, perPage = 30) {
    const { data } = await this.octokit.actions.listWorkflowRunsForRepo({
      owner,
      repo,
      per_page: perPage,
      status: 'in_progress' // Only active runs for smart polling
    });
    return data.workflow_runs;
  }
  
  // Trigger workflow dispatch
  async dispatchWorkflow(owner: string, repo: string, workflowId: string, ref = 'main') {
    await this.octokit.actions.createWorkflowDispatch({
      owner,
      repo,
      workflow_id: workflowId,
      ref,
      inputs: {}
    });
  }
  
  // Get specific workflow run details
  async getWorkflowRun(owner: string, repo: string, runId: number) {
    const { data } = await this.octokit.actions.getWorkflowRun({
      owner,
      repo,
      run_id: runId
    });
    return data;
  }
}
```

**2. Create src/server/github/poller.ts:**

Export polling service with smart backoff:

```typescript
import { GitHubClient } from './client.ts';
import { getRepos, getWorkflowRuns, addWorkflowRun, updateWorkflowRun } from '../db/index.ts';

let pollerInterval: NodeJS.Timeout | null = null;
let backoffDelay = 10000; // Start at 10s
const MAX_DELAY = 60000; // Max 60s between polls

export async function startPoller(client: GitHubClient) {
  if (pollerInterval) return; // Already running
  
  async function poll() {
    const repos = getRepos();
    
    for (const repo of repos) {
      try {
        const runs = await client.listWorkflowRuns(repo.owner, repo.name);
        
        for (const run of runs) {
          const existing = getWorkflowRuns(repo.id, 100).find(r => r.id === run.id);
          
          if (!existing) {
            addWorkflowRun({
              id: run.id,
              repoId: repo.id,
              workflowName: run.name,
              status: run.status,
              conclusion: run.conclusion,
              startedAt: run.run_started_at ? new Date(run.run_started_at).getTime() : null,
              completedAt: run.completed_at ? new Date(run.completed_at).getTime() : null,
              htmlUrl: run.html_url
            });
          } else if (existing.status !== run.status || existing.conclusion !== run.conclusion) {
            updateWorkflowRun(run.id, {
              status: run.status,
              conclusion: run.conclusion,
              completedAt: run.completed_at ? new Date(run.completed_at).getTime() : null
            });
          }
        }
        
        // Reset backoff on success
        backoffDelay = 10000;
      } catch (error) {
        console.error(`Polling error for ${repo.id}:`, error);
        // Exponential backoff on errors (rate limits)
        backoffDelay = Math.min(backoffDelay * 2, MAX_DELAY);
      }
    }
  }
  
  // Initial poll
  await poll();
  
  // Schedule recurring polls
  pollerInterval = setInterval(poll, backoffDelay);
}

export function stopPoller() {
  if (pollerInterval) {
    clearInterval(pollerInterval);
    pollerInterval = null;
  }
}
```

**3. Update src/server/index.ts:**
- Export poller for use by API routes (needed for Task 2b)
- Add placeholder comment: `// Poller will be started in Task 2b after routes registered`
- Stop poller on shutdown using existing graceful shutdown handler
  </action>
  <verify>
**Test client and poller independently:**

1. Start server: `npm run dev`
2. Test client in Node REPL:
   ```javascript
   import { GitHubClient } from './src/server/github/client.ts';
   const client = new GitHubClient(process.env.GITHUB_TOKEN);
   const runs = await client.listWorkflowRuns('octocat', 'Hello-World');
   console.log(runs); // Should show workflow runs
   ```
3. Verify logs show database updates (no "Polling service started" yet - that's Task 2b)
4. Verify poller module exports startPoller/stopPoller functions
  </verify>
  <done>
- GitHubClient class can authenticate and call GitHub API
- listWorkflowRuns, dispatchWorkflow, getWorkflowRun methods work
- Polling service module complete with smart backoff logic
- Database integration tested (addWorkflowRun, updateWorkflowRun)
- No errors when importing/instantiating client
  </done>
</task>

<task type="auto">
  <name>Task 2b: Create API routes for repo and workflow management</name>
  <files>
src/server/routes/repos.ts
src/server/routes/workflows.ts
src/server/index.ts
  </files>
  <action>
Create REST API endpoints for repo management and workflow operations:

**1. Create src/server/routes/repos.ts:**

Export Fastify plugin `repoRoutes` with these endpoints:

- `GET /api/repos`
  - Returns all tracked repos from database
  - Response: `Repo[]`
  
- `POST /api/repos`
  - Body: `{ owner: string, name: string }`
  - Validates not duplicate (check if `owner/name` already exists)
  - Adds repo to database via `addRepo(owner, name)`
  - Returns created repo
  - Status: 201 on success, 409 if duplicate, 400 for validation errors
  
- `DELETE /api/repos/:id`
  - Removes repo by id (format: `owner/name`)
  - Status: 204 on success, 404 if not found

Include proper error handling with try/catch blocks.

**2. Create src/server/routes/workflows.ts:**

Export Fastify plugin `workflowRoutes`:

- `GET /api/repos/:repoId/workflows`
  - Returns workflow runs for repo from database
  - Uses `getWorkflowRuns(repoId, 100)` (last 100 runs)
  - Response: `WorkflowRun[]`
  - Decode repoId from URL (may contain `/` encoded as `%2F`)
  
- `POST /api/repos/:repoId/workflows/:workflowId/dispatch`
  - Triggers workflow via GitHub API
  - Gets GitHub client token from auth context
  - Calls `client.dispatchWorkflow(owner, name, workflowId)`
  - Status: 202 (Accepted), 401 if not authenticated, 500 on GitHub API error

**3. Update src/server/index.ts:**
- Import and register repoRoutes plugin
- Import and register workflowRoutes plugin
- Start poller after routes registered:
  ```typescript
  import { startPoller, stopPoller } from './github/poller.ts';
  import { GitHubClient } from './github/client.ts';
  
  // After all routes registered
  const token = getStoredToken(); // From auth module
  if (token) {
    const client = new GitHubClient(token);
    await startPoller(client);
    server.log.info('Polling service started');
  }
  ```
- Log "Repo routes registered" and "Workflow routes registered"
  </action>
  <verify>
**API endpoint tests (use curl):**

1. Start server: `npm run dev`
2. Add a repo: `curl -X POST http://localhost:3000/api/repos -H "Content-Type: application/json" -d '{"owner":"octocat","name":"Hello-World"}'`
   - Should return 201 with repo object
3. List repos: `curl http://localhost:3000/api/repos`
   - Should show added repo
4. Check database: `sqlite3 data/orchestrator.db "SELECT * FROM repos;"`
5. Wait 15 seconds for first poll
6. Get workflows: `curl http://localhost:3000/api/repos/octocat%2FHello-World/workflows`
   - Should return workflow runs array
7. Verify logs show:
   - "Repo routes registered"
   - "Workflow routes registered"
   - "Polling service started"
   - Poll activity every 10-60s

**Dispatch test (if repo has workflow_dispatch):**
```bash
curl -X POST http://localhost:3000/api/repos/octocat%2FHello-World/workflows/main.yml/dispatch
```
Check GitHub Actions UI - should see new run started.
  </verify>
  <done>
- Repo management endpoints work (GET, POST, DELETE)
- Workflow endpoints work (GET runs, POST dispatch)
- Polling service starts automatically with authenticated client
- Database updates with new/changed workflow runs
- Workflow dispatch triggers actual GitHub Actions runs
- All routes registered and logged
- No rate limit errors (backoff working)
  </done>
</task>

</tasks>

<verification>
**End-to-end GitHub integration check:**

1. Ensure .env has all GITHUB_* variables set
2. Start server: `npm run dev`
3. Complete OAuth flow via browser
4. Add a test repo via API
5. Wait for poller to fetch workflow runs
6. Verify database contains workflow_runs
7. Dispatch a workflow via API
8. Verify run appears in GitHub Actions UI

**Rate limit check:**
```bash
# Check GitHub API rate limit status
curl -H "Authorization: Bearer $TOKEN" https://api.github.com/rate_limit
```

Should show Actions API rate limit usage.
</verification>

<success_criteria>
1. User can complete GitHub OAuth flow and get authenticated
2. Server maintains valid GitHub API token and can make authenticated requests
3. Polling service fetches workflow runs every 10-60 seconds
4. Database updates with workflow status changes (in_progress â†’ completed)
5. User can add/remove repos from tracking list
6. User can trigger workflow dispatch and see it start on GitHub
7. Exponential backoff prevents rate limiting on errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-dashboard/01-02-SUMMARY.md`
</output>
