---
phase: 01-foundation-dashboard
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - package.json
  - index.html
  - src/client/main.tsx
  - src/client/App.tsx
  - src/client/pages/Dashboard.tsx
  - src/client/components/RepoCard.tsx
  - src/client/components/StatusBadge.tsx
  - src/client/lib/api.ts
  - vite.config.ts
  - src/server/index.ts
autonomous: true

must_haves:
  truths:
    - "User can view all configured repos in dashboard"
    - "User can see workflow status for each repo"
    - "User can trigger workflows from UI"
    - "Status indicators show success/failure/running states"
  artifacts:
    - path: "src/client/App.tsx"
      provides: "React application root"
      min_lines: 30
    - path: "src/client/pages/Dashboard.tsx"
      provides: "Main dashboard view"
      min_lines: 80
    - path: "src/client/components/RepoCard.tsx"
      provides: "Repo display with workflows"
      min_lines: 50
    - path: "src/client/components/StatusBadge.tsx"
      provides: "Visual status indicators"
      exports: ["StatusBadge"]
    - path: "src/client/lib/api.ts"
      provides: "Backend API client"
      exports: ["api"]
  key_links:
    - from: "src/client/lib/api.ts"
      to: "GET /api/repos"
      via: "api.getRepos() calls backend route"
      pattern: "fetch.*\\/api\\/repos[^/]"
    - from: "src/client/lib/api.ts"
      to: "POST /api/repos"
      via: "api.addRepo() calls backend route"
      pattern: "fetch.*\\/api\\/repos.*POST"
    - from: "src/client/lib/api.ts"
      to: "GET /api/repos/:id/workflows"
      via: "api.getWorkflows() calls backend route"
      pattern: "fetch.*\\/api\\/repos\\/.*\\/workflows"
    - from: "src/client/lib/api.ts"
      to: "POST /api/repos/:id/workflows/:id/dispatch"
      via: "api.dispatchWorkflow() calls backend route"
      pattern: "fetch.*\\/workflows\\/.*\\/dispatch"
    - from: "src/client/pages/Dashboard.tsx"
      to: "src/client/lib/api.ts"
      via: "Dashboard fetches repos on mount"
      pattern: "api\\.getRepos\\(\\)"
    - from: "src/client/components/RepoCard.tsx"
      to: "src/client/lib/api.ts"
      via: "RepoCard triggers dispatch on button click"
      pattern: "api\\.dispatchWorkflow\\("
---

<objective>
Build React dashboard UI for viewing repos, workflow status, and triggering runs.

Purpose: Create the user-facing interface that ties together all backend functionality—displaying tracked repos, showing real-time workflow status with visual indicators, and providing one-click workflow dispatch.

Output:
- React frontend with Vite dev server
- Dashboard page showing all tracked repos
- Repo cards with workflow status and trigger buttons
- Visual status badges (green/red/yellow)
- API client for backend communication
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-dashboard/01-01-SUMMARY.md
@.planning/phases/01-foundation-dashboard/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize React frontend with Vite</name>
  <files>
package.json
vite.config.ts
index.html
src/client/main.tsx
src/client/App.tsx
src/client/lib/api.ts
src/server/index.ts
  </files>
  <action>
Set up React frontend using Vite for fast development:

**1. Install frontend dependencies:**
```bash
npm install react react-dom react-router-dom
npm install -D vite @vitejs/plugin-react @types/react @types/react-dom
npm install -D tailwindcss postcss autoprefixer
```

**2. Initialize Tailwind CSS:**
```bash
npx tailwindcss init -p
```

Update `tailwind.config.js`:
```javascript
export default {
  content: [
    "./index.html",
    "./src/client/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

Create `src/client/index.css`:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

**3. Create vite.config.ts:**
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  root: '.',
  build: {
    outDir: 'dist/client',
  },
  server: {
    port: 5173,
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
});
```

**4. Create index.html:**
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GSD Orchestrator</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/client/main.tsx"></script>
  </body>
</html>
```

**5. Create src/client/main.tsx:**
```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

**6. Create src/client/App.tsx:**
```typescript
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import Dashboard from './pages/Dashboard';

export default function App() {
  return (
    <BrowserRouter>
      <div className="min-h-screen bg-gray-50">
        <header className="bg-white shadow-sm">
          <div className="max-w-7xl mx-auto px-4 py-4">
            <h1 className="text-2xl font-bold text-gray-900">GSD Orchestrator</h1>
          </div>
        </header>
        
        <main className="max-w-7xl mx-auto px-4 py-8">
          <Routes>
            <Route path="/dashboard" element={<Dashboard />} />
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
          </Routes>
        </main>
      </div>
    </BrowserRouter>
  );
}
```

**7. Create src/client/lib/api.ts:**

**CRITICAL: This client must call the exact backend routes created in Plan 02:**
- `GET /api/repos` → getRepos()
- `POST /api/repos` → addRepo()
- `DELETE /api/repos/:id` → removeRepo()
- `GET /api/repos/:id/workflows` → getWorkflows()
- `POST /api/repos/:id/workflows/:id/dispatch` → dispatchWorkflow()

```typescript
// API client for backend communication
const API_BASE = '/api';

interface Repo {
  id: string;
  owner: string;
  name: string;
  addedAt: number;
  lastPolledAt?: number;
}

interface WorkflowRun {
  id: number;
  repoId: string;
  workflowName: string;
  status: 'queued' | 'in_progress' | 'completed';
  conclusion?: 'success' | 'failure' | 'cancelled' | 'skipped';
  startedAt?: number;
  completedAt?: number;
  htmlUrl: string;
}

export const api = {
  // Calls GET /api/repos (from Plan 02 Task 2b)
  async getRepos(): Promise<Repo[]> {
    const res = await fetch(`${API_BASE}/repos`);
    if (!res.ok) throw new Error('Failed to fetch repos');
    return res.json();
  },
  
  // Calls POST /api/repos (from Plan 02 Task 2b)
  async addRepo(owner: string, name: string): Promise<Repo> {
    const res = await fetch(`${API_BASE}/repos`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ owner, name })
    });
    if (!res.ok) throw new Error('Failed to add repo');
    return res.json();
  },
  
  // Calls DELETE /api/repos/:id (from Plan 02 Task 2b)
  async removeRepo(id: string): Promise<void> {
    const res = await fetch(`${API_BASE}/repos/${encodeURIComponent(id)}`, {
      method: 'DELETE'
    });
    if (!res.ok) throw new Error('Failed to remove repo');
  },
  
  // Calls GET /api/repos/:repoId/workflows (from Plan 02 Task 2b)
  async getWorkflows(repoId: string): Promise<WorkflowRun[]> {
    const res = await fetch(`${API_BASE}/repos/${encodeURIComponent(repoId)}/workflows`);
    if (!res.ok) throw new Error('Failed to fetch workflows');
    return res.json();
  },
  
  // Calls POST /api/repos/:repoId/workflows/:workflowId/dispatch (from Plan 02 Task 2b)
  async dispatchWorkflow(repoId: string, workflowId: string): Promise<void> {
    const res = await fetch(`${API_BASE}/repos/${encodeURIComponent(repoId)}/workflows/${workflowId}/dispatch`, {
      method: 'POST'
    });
    if (!res.ok) throw new Error('Failed to dispatch workflow');
  }
};
```

**8. Update src/server/index.ts:**
- Add static file serving for production build:
```typescript
import fastifyStatic from '@fastify/static';
import path from 'path';

// After other routes, add:
server.register(fastifyStatic, {
  root: path.join(__dirname, '../../dist/client'),
  prefix: '/'
});

// Fallback for SPA routing (return index.html for non-API routes)
server.setNotFoundHandler((request, reply) => {
  if (request.url.startsWith('/api')) {
    reply.code(404).send({ error: 'Not found' });
  } else {
    reply.sendFile('index.html');
  }
});
```

**9. Add npm scripts to package.json:**
```json
"scripts": {
  "dev": "tsx watch src/server/index.ts",
  "dev:client": "vite",
  "build": "tsc && vite build",
  "start": "node dist/server/index.js"
}
```
  </action>
  <verify>
1. Start backend: `npm run dev` (in one terminal)
2. Start frontend: `npm run dev:client` (in another terminal)
3. Visit http://localhost:5173 (Vite dev server)
4. Verify React app renders with header "GSD Orchestrator"
5. Check browser console for no errors
6. Verify Vite proxy: API requests go to backend (check Network tab)
7. Test build: `npm run build` (should compile without errors)
  </verify>
  <done>
- React app renders in browser
- Vite dev server runs on port 5173
- Tailwind CSS styles applied
- API client can make requests to backend
- No TypeScript or build errors
- React Router navigation works
  </done>
</task>

<task type="auto">
  <name>Task 2: Build dashboard UI with repo cards and status indicators</name>
  <files>
src/client/pages/Dashboard.tsx
src/client/components/RepoCard.tsx
src/client/components/StatusBadge.tsx
src/client/components/AddRepoForm.tsx
  </files>
  <action>
Create the main dashboard interface with repo management and workflow status:

**1. Create src/client/components/StatusBadge.tsx:**
```typescript
import React from 'react';

interface StatusBadgeProps {
  status: 'queued' | 'in_progress' | 'completed';
  conclusion?: 'success' | 'failure' | 'cancelled' | 'skipped';
}

export function StatusBadge({ status, conclusion }: StatusBadgeProps) {
  // Determine color based on status/conclusion
  let colorClass = 'bg-gray-500'; // default
  let text = status;
  
  if (status === 'completed' && conclusion) {
    text = conclusion;
    switch (conclusion) {
      case 'success':
        colorClass = 'bg-green-500';
        break;
      case 'failure':
        colorClass = 'bg-red-500';
        break;
      case 'cancelled':
        colorClass = 'bg-gray-500';
        break;
      case 'skipped':
        colorClass = 'bg-yellow-500';
        break;
    }
  } else if (status === 'in_progress') {
    colorClass = 'bg-blue-500 animate-pulse';
    text = 'running';
  } else if (status === 'queued') {
    colorClass = 'bg-yellow-500';
  }
  
  return (
    <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium text-white ${colorClass}`}>
      {text}
    </span>
  );
}
```

**2. Create src/client/components/RepoCard.tsx:**
```typescript
import React, { useEffect, useState } from 'react';
import { api } from '../lib/api';
import { StatusBadge } from './StatusBadge';

interface WorkflowRun {
  id: number;
  repoId: string;
  workflowName: string;
  status: 'queued' | 'in_progress' | 'completed';
  conclusion?: 'success' | 'failure' | 'cancelled' | 'skipped';
  startedAt?: number;
  completedAt?: number;
  htmlUrl: string;
}

interface RepoCardProps {
  repo: {
    id: string;
    owner: string;
    name: string;
    addedAt: number;
    lastPolledAt?: number;
  };
  onRemove: () => void;
}

export function RepoCard({ repo, onRemove }: RepoCardProps) {
  const [workflows, setWorkflows] = useState<WorkflowRun[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function fetchWorkflows() {
      try {
        const data = await api.getWorkflows(repo.id);
        setWorkflows(data.slice(0, 5)); // Show latest 5 runs
      } catch (error) {
        console.error('Failed to fetch workflows:', error);
      } finally {
        setLoading(false);
      }
    }
    
    fetchWorkflows();
    
    // Poll for updates every 10 seconds
    const interval = setInterval(fetchWorkflows, 10000);
    return () => clearInterval(interval);
  }, [repo.id]);
  
  const handleDispatch = async (workflowId: string) => {
    try {
      await api.dispatchWorkflow(repo.id, workflowId);
      alert(`Workflow ${workflowId} dispatched!`);
    } catch (error) {
      alert(`Failed to dispatch workflow: ${error}`);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <div className="flex items-start justify-between mb-4">
        <div>
          <h3 className="text-lg font-semibold text-gray-900">
            {repo.owner}/{repo.name}
          </h3>
          <p className="text-sm text-gray-500">
            Added {new Date(repo.addedAt).toLocaleDateString()}
          </p>
        </div>
        <button
          onClick={onRemove}
          className="text-red-600 hover:text-red-800 text-sm"
        >
          Remove
        </button>
      </div>
      
      <div className="space-y-3">
        {loading ? (
          <p className="text-sm text-gray-500">Loading workflows...</p>
        ) : workflows.length === 0 ? (
          <p className="text-sm text-gray-500">No recent workflow runs</p>
        ) : (
          workflows.map((workflow) => (
            <div key={workflow.id} className="flex items-center justify-between border-t pt-3">
              <div className="flex-1">
                <a
                  href={workflow.htmlUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-sm font-medium text-blue-600 hover:underline"
                >
                  {workflow.workflowName}
                </a>
                <p className="text-xs text-gray-500">
                  {workflow.startedAt
                    ? new Date(workflow.startedAt).toLocaleString()
                    : 'Not started'}
                </p>
              </div>
              <StatusBadge status={workflow.status} conclusion={workflow.conclusion} />
            </div>
          ))
        )}
      </div>
      
      <div className="mt-4 pt-4 border-t">
        <button
          onClick={() => handleDispatch('main.yml')}
          className="w-full bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm"
        >
          Trigger Workflow
        </button>
      </div>
      
      {/* NOTE: Phase 1 MVP assumes all repos have 'main.yml' workflow file.
          Phase 2 will add workflow discovery/selection UI. This is acceptable
          for MVP testing with controlled repos. Document in SUMMARY. */}
    </div>
  );
}
```

**3. Create src/client/components/AddRepoForm.tsx:**
```typescript
import React, { useState } from 'react';

interface AddRepoFormProps {
  onAdd: (owner: string, name: string) => Promise<void>;
}

export function AddRepoForm({ onAdd }: AddRepoFormProps) {
  const [owner, setOwner] = useState('');
  const [name, setName] = useState('');
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!owner.trim() || !name.trim()) return;
    
    setLoading(true);
    try {
      await onAdd(owner.trim(), name.trim());
      setOwner('');
      setName('');
    } catch (error) {
      alert(`Failed to add repo: ${error}`);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="bg-white rounded-lg shadow-md p-6 mb-6">
      <h2 className="text-lg font-semibold mb-4">Add Repository</h2>
      <div className="flex gap-4">
        <input
          type="text"
          placeholder="Owner (e.g., octocat)"
          value={owner}
          onChange={(e) => setOwner(e.target.value)}
          className="flex-1 px-4 py-2 border rounded focus:ring-2 focus:ring-blue-500"
          disabled={loading}
        />
        <input
          type="text"
          placeholder="Repository name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="flex-1 px-4 py-2 border rounded focus:ring-2 focus:ring-blue-500"
          disabled={loading}
        />
        <button
          type="submit"
          disabled={loading}
          className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {loading ? 'Adding...' : 'Add'}
        </button>
      </div>
    </form>
  );
}
```

**4. Create src/client/pages/Dashboard.tsx:**
```typescript
import React, { useEffect, useState } from 'react';
import { api } from '../lib/api';
import { RepoCard } from '../components/RepoCard';
import { AddRepoForm } from '../components/AddRepoForm';

interface Repo {
  id: string;
  owner: string;
  name: string;
  addedAt: number;
  lastPolledAt?: number;
}

export default function Dashboard() {
  const [repos, setRepos] = useState<Repo[]>([]);
  const [loading, setLoading] = useState(true);
  
  const loadRepos = async () => {
    try {
      const data = await api.getRepos();
      setRepos(data);
    } catch (error) {
      console.error('Failed to load repos:', error);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    loadRepos();
  }, []);
  
  const handleAddRepo = async (owner: string, name: string) => {
    await api.addRepo(owner, name);
    await loadRepos();
  };
  
  const handleRemoveRepo = async (id: string) => {
    if (!confirm(`Remove ${id}?`)) return;
    await api.removeRepo(id);
    await loadRepos();
  };
  
  return (
    <div>
      <AddRepoForm onAdd={handleAddRepo} />
      
      {loading ? (
        <p className="text-gray-600">Loading repositories...</p>
      ) : repos.length === 0 ? (
        <div className="text-center py-12">
          <p className="text-gray-600 text-lg">No repositories tracked yet</p>
          <p className="text-gray-500 text-sm mt-2">Add a repository above to get started</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {repos.map((repo) => (
            <RepoCard
              key={repo.id}
              repo={repo}
              onRemove={() => handleRemoveRepo(repo.id)}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

Use semantic HTML, accessible ARIA labels where needed, and responsive design (grid layout adapts to screen size).

**Phase 1 MVP Assumption:** Workflow dispatch hardcodes 'main.yml' workflow ID. This assumes all tracked repos have a `.github/workflows/main.yml` file with `workflow_dispatch` trigger. This is acceptable for Phase 1 MVP testing. Phase 2 will add proper workflow discovery (listing available workflows) and selection UI. Document this limitation in SUMMARY.md.
  </action>
  <verify>
**Full UI test flow:**

1. Ensure backend is running with GitHub auth configured
2. Start frontend: `npm run dev:client`
3. Visit http://localhost:5173/dashboard
4. Test adding a repo (e.g., "octocat" / "Hello-World")
5. Verify repo card appears with:
   - Repo name displayed correctly
   - "No recent workflow runs" message if no active runs
   - "Trigger Workflow" button enabled
6. Wait 10 seconds, verify workflows auto-refresh
7. If repo has active runs:
   - Verify status badges show correct colors
   - Green = success, Red = failure, Blue pulsing = running, Yellow = queued
8. Click workflow link, verify opens GitHub in new tab
9. Click "Remove" button, verify repo disappears
10. Check browser console for no errors

**Visual inspection:**
- Cards have proper spacing and shadows
- Buttons have hover states
- Form inputs have focus rings
- Layout is responsive (resize browser window)
  </verify>
  <done>
- Dashboard shows all tracked repos in card layout
- Status badges display correct colors for workflow states
- Workflows auto-refresh every 10 seconds
- User can add new repos via form
- User can remove repos with confirmation
- User can trigger workflows with button click
- UI is responsive and accessible
- No console errors during normal operation
  </done>
</task>

</tasks>

<verification>
**Full Phase 1 integration test:**

1. **Backend running:** `npm run dev` (port 3000)
2. **Frontend running:** `npm run dev:client` (port 5173)
3. **OAuth flow:** Visit dashboard, should see UI (skip auth for now if not configured)
4. **Add repo:** Enter owner/name, click Add, verify card appears
5. **Workflow status:** Wait for polling, verify status badges appear with correct colors
6. **Trigger workflow:** Click "Trigger Workflow" button, verify GitHub Actions starts
7. **Status update:** Wait 20s, refresh, verify status changes reflected (e.g., queued → running → success)
8. **Remove repo:** Click Remove, verify disappears from dashboard
9. **Persistence:** Restart server, verify repos still tracked (SQLite persisted)

**Success indicators:**
- All 7 Phase 1 requirements satisfied (AUTH-01, AUTH-02, AUTH-03, DASH-01, DASH-02, DASH-03, EXEC-01)
- No 500 errors in backend logs
- No console errors in browser
- Database contains repos and workflow_runs
- Polling service running with 10-60s interval
</verification>

<success_criteria>
1. User can view all tracked repos in unified dashboard with grid layout
2. User can see workflow status (queued/running/success/failure) with color-coded badges
3. User can add new repos and see them persist across app restarts
4. User can remove repos and see them disappear immediately
5. User can trigger workflows manually and see status change in UI
6. Dashboard auto-refreshes workflow status every 10 seconds
7. UI is responsive and accessible with no console errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-dashboard/01-03-SUMMARY.md`
</output>
